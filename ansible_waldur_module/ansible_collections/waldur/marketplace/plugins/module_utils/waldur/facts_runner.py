"""
This module contains the FactsRunner class, which provides the runtime logic
for read-only Ansible modules generated by the 'facts' plugin.

The primary purpose of a 'facts' module is to gather and return information
about existing resources in Waldur without making any changes. This runner is
designed to be highly configurable through its context, allowing it to handle
various resources, filtering options, and return value expectations.

It uses a composed ParameterResolver to handle the resolution of context
parameters (like 'project' or 'tenant'), ensuring a clean separation of concerns
and consistent logic across all module types.
"""

from ansible_collections.waldur.marketplace.plugins.module_utils.waldur.base_runner import (
    BaseRunner,
)
from ansible_collections.waldur.marketplace.plugins.module_utils.waldur.resolver import (
    ParameterResolver,
)


class FactsRunner(BaseRunner):
    """
    A runner for Ansible modules that only retrieve information ('facts').

    It orchestrates the process of:
    1. Parsing user-provided identifiers and context filters.
    2. Resolving context filter names/UUIDs into the necessary query parameters.
    3. Querying the Waldur API to find the requested resources.
    4. Enforcing expectations about the number of results (e.g., finding exactly one
       resource vs. a list of many).
    5. Formatting and returning the final data to the Ansible user.
    """

    def __init__(self, module, context):
        """
        Initializes the runner and its composed ParameterResolver.

        This follows the composition-over-inheritance pattern, where the runner
        "has a" resolver to which it delegates all parameter resolution tasks.

        Args:
            module: The AnsibleModule instance, providing access to parameters and exit functions.
            context: The pre-processed configuration dictionary from the generator,
                     containing all necessary API paths, parameter names, and resolver configs.
        """
        super().__init__(module, context)
        # Instantiate the resolver, passing this runner instance to it. This gives the
        # resolver access to the runner's send_request method, context, and module.
        self.resolver = ParameterResolver(self)

    def run(self):
        """
        The main execution entry point for the runner. It orchestrates the entire
        workflow of finding resources and exiting with the results.
        """
        # Step 1: Query the API to find all resources matching the user's criteria.
        resources = self._find_resources()

        # Step 2: Process the results and exit the module, handling different
        # scenarios based on the module's configuration (e.g., `many: true/false`).
        self._exit_facts(resources)

    def _find_resources(self) -> list:
        """
        Finds resources based on the user-provided identifier and any context filters.

        This method intelligently decides whether to perform a direct lookup by UUID
        (for efficiency) or a filtered search by name and other context parameters.

        Returns:
            A list of matching resource dictionaries. This method guarantees returning
            a list, even if it's empty, to provide a consistent return type.
        """
        identifier_param = self.context["identifier_param"]
        value = self.module.params.get(identifier_param)

        # --- Path 1: Direct Lookup by UUID (Most Efficient) ---
        # If the user provides a valid UUID as the main identifier, we can fetch the
        # resource directly from its specific endpoint, bypassing the need for a search.
        if self._is_uuid(value):
            resource, _ = self.send_request(
                "GET", self.context["retrieve_url"], path_params={"uuid": value}
            )
            # We wrap the single result in a list to maintain a consistent return type.
            return [resource] if resource else []

        # --- Path 2: Filtered Search by Name and/or Context ---
        # If the identifier is not a UUID (i.e., it's a name) or is not provided at all,
        # we build a dictionary of query parameters to search the list endpoint.
        query_params = {}

        # Add the primary identifier (name) to the search if it was provided.
        if value:
            query_params["name_exact"] = value

        # Resolve all configured context parameters (e.g., 'project', 'tenant').
        resolvers_config = self.context.get("resolvers", {})
        for param_name, resolver_info in resolvers_config.items():
            # Check if the user included this context parameter in their playbook.
            if self.module.params.get(param_name):
                # Delegate the resolution of the context parameter's name/UUID to our
                # centralized resolver utility.
                resolved_url = self.resolver.resolve_to_url(
                    param_name=param_name, value=self.module.params[param_name]
                )

                # Extract the UUID from the end of the resolved URL.
                if resolved_url:
                    # Robustly get the last non-empty part of the URL path.
                    resolved_uuid = resolved_url.strip("/").split("/")[-1]
                    # Use the 'filter_key' from the context (e.g., 'project_uuid') to
                    # add the final query parameter.
                    query_params[resolver_info["filter_key"]] = resolved_uuid

        # Perform the final API call with the combined dictionary of filters.
        data, _ = self.send_request(
            "GET", self.context["list_url"], query_params=query_params
        )

        return data if data else []

    def _exit_facts(self, resources: list):
        """
        Exits the module, returning the found resource(s) in the final JSON output.

        This method's behavior is critically controlled by the `many` flag in the
        module's configuration. It enforces whether zero, one, or multiple results
        constitute a successful run.

        Args:
            resources: The list of resource dictionaries returned by `_find_resources`.
        """

        # --- Behavior for `many: false` (the default) ---
        # In this mode, the module is expected to find *exactly one* resource.
        # This is for tasks where the user wants to get facts about a single, specific item.
        if not self.context.get("many", False):
            if not resources:
                self.module.fail_json(
                    msg=f"A single {self.context['resource_type']} was not found with the specified parameters."
                )
                return  # Unreachable

            if len(resources) > 1:
                self.module.fail_json(
                    msg=(
                        f"Multiple {self.context['resource_type']}s found, but expected only one. "
                        "Please provide a more specific identifier or use a module designed to handle multiple items."
                    )
                )
                return  # Unreachable

        # --- Behavior for `many: true` ---
        # In this mode, the module is designed to return a list of all resources that
        # match the filter. An empty list is a valid, successful result.

        # The final result payload for Ansible. 'changed' is always false for facts modules.
        result_payload = {
            "changed": False,
            # The result is always a list, providing a consistent data structure for users.
            "resources": resources,
        }

        self.module.exit_json(**result_payload)
